shoot.radius:object/src/Player.cpp:    auto const tex_size = this->body_tex_.getSize();
shoot.radius:object/src/Player.cpp:    this->body.setOrigin(sf::Vector2<float>(tex_size / 2U));
shoot.radius:object/src/Player.cpp:    this->reticle.setOrigin(
shoot.radius:object/src/Player.cpp:      sf::Vector2<float>(this->reticle_tex_.getSize() / 2U)
shoot.radius:object/src/Player.cpp:    this->body.setPosition(position);
shoot.radius:object/src/Player.cpp:    this->mov.up = dir.normalized();
shoot.radius:object/src/Player.cpp:    this->mov.right = dir.perpendicular().normalized();
shoot.radius:object/src/Player.cpp:    this->mov.body_vel = velocity;
shoot.radius:object/src/Player.cpp:    this->set_mode(std::make_unique<RapidFire>());
shoot.radius:object/src/Player.cpp:    this->update_frame(ctx, dt);
shoot.radius:object/src/Player.cpp:    if (this->shoot.strength.lengthSquared() > internal::EPSILON) {
shoot.radius:object/src/Player.cpp:      this->mov.up = this->shoot.strength;
shoot.radius:object/src/Player.cpp:    if (fabsf(this->mov.up.lengthSquared() - 1.F) > internal::EPSILON) {
shoot.radius:object/src/Player.cpp:      this->mov.up = this->mov.up.normalized();
shoot.radius:object/src/Player.cpp:    this->mov.right = this->mov.up.perpendicular().normalized();
shoot.radius:object/src/Player.cpp:    if (this->mov.strength.lengthSquared() > 0) {
shoot.radius:object/src/Player.cpp:      dir = this->mov.strength.normalized();
shoot.radius:object/src/Player.cpp:    auto disp = dir * this->mov.body_vel * dt;
shoot.radius:object/src/Player.cpp:    this->bind(ctx.world_size, disp);
shoot.radius:object/src/Player.cpp:    this->body.move(disp);
shoot.radius:object/src/Player.cpp:    this->body.setRotation(this->mov.up.angle() + sf::radians(M_PIf / 2));
shoot.radius:object/src/Player.cpp:    if (this->shoot.strength.lengthSquared() == 0) {
shoot.radius:object/src/Player.cpp:      this->reticle.setColor(sf::Color::Transparent);
shoot.radius:object/src/Player.cpp:    this->reticle.setColor(sf::Color::Cyan);
shoot.radius:object/src/Player.cpp:    if (this->mov.strength.lengthSquared() > 0) {
shoot.radius:object/src/Player.cpp:      ret_disp = -this->mov.strength.normalized();
shoot.radius:object/src/Player.cpp:    auto const par_disp = ret_disp.projectedOnto(this->mov.up);
shoot.radius:object/src/Player.cpp:      (4.F * par_disp + 3.F * per_disp) * this->shoot.radius / 8.F;
shoot.radius:object/src/Player.cpp:      adjusted_disp + 1.5F * this->shoot.radius * this->mov.up;
shoot.radius:object/src/Player.cpp:    this->reticle.setPosition(
shoot.radius:object/src/Player.cpp:      smoothen(this->body.getPosition() + total_disp, 3)
shoot.radius:object/src/Player.cpp:    auto new_pos = this->body.getPosition() + disp;
shoot.radius:object/src/Player.cpp:    this->mode_ = std::move(mode);
shoot.radius:object/src/Player.cpp:    return this->mode_->fire(*this, ctx, dt);
shoot.radius:object/src/Player.cpp:        BulletType::STRAIGHT, pos1, this->velocity, p.forward()
shoot.radius:object/src/Player.cpp:        BulletType::STRAIGHT, pos2, this->velocity, p.forward()
shoot.radius:object/src/Player.cpp:      this->last_stamp = ctx.cur_time();
shoot.radius:object/src/Player.cpp:      static_cast<float>(ctx.cur_time() - this->last_stamp);
shoot.radius:object/src/Player.cpp:    this->in_cooldown = (duration / (1000 * dt)) < this->cooldown;
shoot.radius:object/src/Bullet.cpp:    this->set_behaviour(info.obj_type);
shoot.radius:object/src/Bullet.cpp:    this->sprite.setPosition(info.position);
shoot.radius:object/src/Bullet.cpp:    this->sprite.scale({2.5F, 2.5F});
shoot.radius:object/src/Bullet.cpp:    this->sprite.setOrigin(
shoot.radius:object/src/Bullet.cpp:      sf::Vector2<float>(this->sprite.getTexture().getSize() / 2U)
shoot.radius:object/src/Bullet.cpp:    this->mov.up = info.dir;
shoot.radius:object/src/Bullet.cpp:    this->mov.body_vel = info.velocity;
shoot.radius:object/src/Bullet.cpp:    this->update_frame();
shoot.radius:object/src/Bullet.cpp:    this->update_frame();
shoot.radius:object/src/Bullet.cpp:    this->lifetime -= dt;
shoot.radius:object/src/Bullet.cpp:      this->behaviour
shoot.radius:object/src/Bullet.cpp:    this->mov.set_vel(this->mov.velocity() + accel * dt);
shoot.radius:object/src/Bullet.cpp:    auto disp = this->mov.velocity() * dt;
shoot.radius:object/src/Bullet.cpp:    this->sprite.move(disp);
shoot.radius:object/src/Bullet.cpp:    this->sprite.setRotation(
shoot.radius:object/src/Bullet.cpp:      this->mov.up.angle() + sf::radians(M_PIf / 2)
shoot.radius:object/src/Bullet.cpp:    this->set_alive(wld_ctx);
shoot.radius:object/src/Bullet.cpp:    this->alive = true;
shoot.radius:object/src/Bullet.cpp:    this->set_behaviour(info.obj_type);
shoot.radius:object/src/Bullet.cpp:    this->mov.body_vel = info.velocity;
shoot.radius:object/src/Bullet.cpp:    this->mov.up = info.dir;
shoot.radius:object/src/Bullet.cpp:    this->sprite.setPosition(info.position);
shoot.radius:object/src/Bullet.cpp:    this->lifetime = info.lifetime;
shoot.radius:object/src/Bullet.cpp:    this->update_frame();
shoot.radius:object/src/Bullet.cpp:    if (std::fabsf(this->mov.up.lengthSquared() - 1.0F) >
shoot.radius:object/src/Bullet.cpp:      this->mov.up = this->mov.up.normalized();
shoot.radius:object/src/Bullet.cpp:    this->mov.right = this->mov.up.perpendicular().normalized();
shoot.radius:object/src/Bullet.cpp:      ctx.world_size.contains(this->sprite.getPosition());
shoot.radius:object/src/Bullet.cpp:    bool const time_check = this->lifetime > 0;
shoot.radius:src/SFMLApp.cpp:    wld_ctx(this->window_.getSize(), this->clock_)
shoot.radius:src/SFMLApp.cpp:    this->window_.setFramerateLimit(60);
shoot.radius:src/SFMLApp.cpp:    this->window_.setPosition(
shoot.radius:src/SFMLApp.cpp:    this->window_.setKeyRepeatEnabled(false);
shoot.radius:src/SFMLApp.cpp:    this->settings.antiAliasingLevel = 8;
shoot.radius:src/SFMLApp.cpp:    this->log_text_.setFillColor(sf::Color::Yellow);
shoot.radius:src/SFMLApp.cpp:      this->update_log("Joystick 0 connected");
shoot.radius:src/SFMLApp.cpp:    while (this->window_.isOpen()) {
shoot.radius:src/SFMLApp.cpp:      this->dt = this->clock_.getElapsedTime().asSeconds() - last_stamp;
shoot.radius:src/SFMLApp.cpp:      last_stamp = this->clock_.getElapsedTime().asSeconds();
shoot.radius:src/SFMLApp.cpp:      this->window_.clear();
shoot.radius:src/SFMLApp.cpp:      this->window_.handleEvents([this](auto const& event) {
shoot.radius:src/SFMLApp.cpp:        this->handle(event);
shoot.radius:src/SFMLApp.cpp:      this->fire_check();
shoot.radius:src/SFMLApp.cpp:      this->player_.move(wld_ctx, dt);
shoot.radius:src/SFMLApp.cpp:      for (auto& obj : this->bullet_pool_) {
shoot.radius:src/SFMLApp.cpp:        obj.update(this->wld_ctx, this->str_ctx, dt);
shoot.radius:src/SFMLApp.cpp:      this->window_.draw(this->player_.body);
shoot.radius:src/SFMLApp.cpp:      this->window_.draw(this->player_.reticle);
shoot.radius:src/SFMLApp.cpp:      for (auto const& obj : this->bullet_pool_) {
shoot.radius:src/SFMLApp.cpp:        this->window_.draw(obj.sprite);
shoot.radius:src/SFMLApp.cpp:      this->bullet_pool_.release();
shoot.radius:src/SFMLApp.cpp:      this->update_log(
shoot.radius:src/SFMLApp.cpp:        std::format("Bullet Count: {}", this->bullet_pool_.size())
shoot.radius:src/SFMLApp.cpp:      this->log();
shoot.radius:src/SFMLApp.cpp:      this->window_.display();
shoot.radius:src/SFMLApp.cpp:    for (std::size_t i = 0; i < this->logs_.size(); ++i) {
shoot.radius:src/SFMLApp.cpp:      this->log_text_.setPosition(
shoot.radius:src/SFMLApp.cpp:      this->log_text_.setString(this->logs_[i]);
shoot.radius:src/SFMLApp.cpp:      this->window_.draw(this->log_text_);
shoot.radius:src/SFMLApp.cpp:    if (this->logs_.size() == 12U) {
shoot.radius:src/SFMLApp.cpp:      this->logs_.pop_front();
shoot.radius:src/SFMLApp.cpp:    this->logs_.emplace_back(text);
shoot.radius:src/SFMLApp.cpp:    if (this->player_.shoot.strength.lengthSquared() > 0) {
shoot.radius:src/SFMLApp.cpp:        this->player_.fire(this->wld_ctx, dt),
shoot.radius:src/SFMLApp.cpp:        [this](auto const& info) { this->bullet_pool_.get(info); }
shoot.radius:src/SFMLApp.cpp:    this->window_.close();
shoot.radius:src/SFMLApp.cpp:      this->window_.close();
shoot.radius:src/SFMLApp.cpp:    this->update_log(std::format("Pressed Button: {}", event.button));
shoot.radius:src/SFMLApp.cpp:      this->deadzone(
shoot.radius:src/SFMLApp.cpp:        this->player_.mov.strength, {pos, this->player_.mov.strength.y}
shoot.radius:src/SFMLApp.cpp:      this->deadzone(
shoot.radius:src/SFMLApp.cpp:        this->player_.mov.strength, {this->player_.mov.strength.x, pos}
shoot.radius:src/SFMLApp.cpp:      this->deadzone(
shoot.radius:src/SFMLApp.cpp:        this->player_.shoot.strength, {pos, this->player_.shoot.strength.y}
shoot.radius:src/SFMLApp.cpp:      this->deadzone(
shoot.radius:src/SFMLApp.cpp:        this->player_.shoot.strength, {this->player_.shoot.strength.x, pos}
shoot.radius:src/SFMLApp.cpp:    // this->update_log("Unhandled Event\n");
shoot.radius:object/include/Player.hpp:    sf::Vector2f const& forward() const { return this->mov.up; }
shoot.radius:object/include/Player.hpp:    sf::Vector2f const& right() const { return this->mov.right; }
shoot.radius:object/include/helpers.hpp:      sf::Vector2f velocity() const { return this->up * this->body_vel; }
shoot.radius:object/include/helpers.hpp:        this->up = vel.normalized();
shoot.radius:object/include/helpers.hpp:        this->body_vel = vel.length();
shoot.radius:object/include/Object.hpp:    size_t size() const { return this->objects_.size(); }
shoot.radius:object/include/Object.hpp:    iterator begin() { return this->objects_.begin(); }
shoot.radius:object/include/Object.hpp:    iterator end() { return this->objects_.begin() + this->last_; }
shoot.radius:object/include/Object.hpp:    const_iterator begin() const { return this->objects_.begin(); }
shoot.radius:object/include/Object.hpp:      return this->objects_.begin() + this->last_;
shoot.radius:object/include/Object.hpp:    if (this->last_ == this->objects_.size()) {
shoot.radius:object/include/Object.hpp:      this->objects_.emplace_back(internal::build_object<Object>(info));
shoot.radius:object/include/Object.hpp:      this->last_++;
shoot.radius:object/include/Object.hpp:    auto& obj = this->objects_[this->last_];
shoot.radius:object/include/Object.hpp:    this->last_++;
shoot.radius:object/include/Object.hpp:    while (idx < this->last_) {
shoot.radius:object/include/Object.hpp:      auto& obj = this->objects_[idx++];
shoot.radius:object/include/Object.hpp:        std::swap(obj, this->objects_[--this->last_]);
shoot.radius:object/include/Bullet.hpp:      return this->track.accel(ctx);
shoot.radius:object/include/Bullet.hpp:    bool isAlive() const { return this->alive; }
object/src/Player.cpp:    auto const tex_size = this->body_tex_.getSize();
object/src/Player.cpp:    this->body.setOrigin(sf::Vector2<float>(tex_size / 2U));
object/src/Player.cpp:    this->reticle.setOrigin(
object/src/Player.cpp:      sf::Vector2<float>(this->reticle_tex_.getSize() / 2U)
object/src/Player.cpp:    this->body.setPosition(position);
object/src/Player.cpp:    this->mov.up = dir.normalized();
object/src/Player.cpp:    this->mov.right = dir.perpendicular().normalized();
object/src/Player.cpp:    this->mov.body_vel = velocity;
object/src/Player.cpp:    this->set_mode(std::make_unique<RapidFire>());
object/src/Player.cpp:    this->update_frame(ctx, dt);
object/src/Player.cpp:    if (this->shoot.strength.lengthSquared() > internal::EPSILON) {
object/src/Player.cpp:      this->mov.up = this->shoot.strength;
object/src/Player.cpp:    if (fabsf(this->mov.up.lengthSquared() - 1.F) > internal::EPSILON) {
object/src/Player.cpp:      this->mov.up = this->mov.up.normalized();
object/src/Player.cpp:    this->mov.right = this->mov.up.perpendicular().normalized();
object/src/Player.cpp:    if (this->mov.strength.lengthSquared() > 0) {
object/src/Player.cpp:      dir = this->mov.strength.normalized();
object/src/Player.cpp:    auto disp = dir * this->mov.body_vel * dt;
object/src/Player.cpp:    this->bind(ctx.world_size, disp);
object/src/Player.cpp:    this->body.move(disp);
object/src/Player.cpp:    this->body.setRotation(this->mov.up.angle() + sf::radians(M_PIf / 2));
object/src/Player.cpp:    if (this->shoot.strength.lengthSquared() == 0) {
object/src/Player.cpp:      this->reticle.setColor(sf::Color::Transparent);
object/src/Player.cpp:    this->reticle.setColor(sf::Color::Cyan);
object/src/Player.cpp:    if (this->mov.strength.lengthSquared() > 0) {
object/src/Player.cpp:      ret_disp = -this->mov.strength.normalized();
object/src/Player.cpp:    auto const par_disp = ret_disp.projectedOnto(this->mov.up);
object/src/Player.cpp:      (4.F * par_disp + 3.F * per_disp) * this->shoot.radius / 8.F;
object/src/Player.cpp:      adjusted_disp + 1.5F * this->shoot.radius * this->mov.up;
object/src/Player.cpp:    this->reticle.setPosition(
object/src/Player.cpp:      smoothen(this->body.getPosition() + total_disp, 3)
object/src/Player.cpp:    auto new_pos = this->body.getPosition() + disp;
object/src/Player.cpp:    this->mode_ = std::move(mode);
object/src/Player.cpp:    return this->mode_->fire(*this, ctx, dt);
object/src/Player.cpp:        BulletType::STRAIGHT, pos1, this->velocity, p.forward()
object/src/Player.cpp:        BulletType::STRAIGHT, pos2, this->velocity, p.forward()
object/src/Player.cpp:      this->last_stamp = ctx.cur_time();
object/src/Player.cpp:      static_cast<float>(ctx.cur_time() - this->last_stamp);
object/src/Player.cpp:    this->in_cooldown = (duration / (1000 * dt)) < this->cooldown;
object/src/Bullet.cpp:    this->set_behaviour(info.obj_type);
object/src/Bullet.cpp:    this->sprite.setPosition(info.position);
object/src/Bullet.cpp:    this->sprite.scale({2.5F, 2.5F});
object/src/Bullet.cpp:    this->sprite.setOrigin(
object/src/Bullet.cpp:      sf::Vector2<float>(this->sprite.getTexture().getSize() / 2U)
object/src/Bullet.cpp:    this->mov.up = info.dir;
object/src/Bullet.cpp:    this->mov.body_vel = info.velocity;
object/src/Bullet.cpp:    this->update_frame();
object/src/Bullet.cpp:    this->update_frame();
object/src/Bullet.cpp:    this->lifetime -= dt;
object/src/Bullet.cpp:      this->behaviour
object/src/Bullet.cpp:    this->mov.set_vel(this->mov.velocity() + accel * dt);
object/src/Bullet.cpp:    auto disp = this->mov.velocity() * dt;
object/src/Bullet.cpp:    this->sprite.move(disp);
object/src/Bullet.cpp:    this->sprite.setRotation(
object/src/Bullet.cpp:      this->mov.up.angle() + sf::radians(M_PIf / 2)
object/src/Bullet.cpp:    this->set_alive(wld_ctx);
object/src/Bullet.cpp:    this->alive = true;
object/src/Bullet.cpp:    this->set_behaviour(info.obj_type);
object/src/Bullet.cpp:    this->mov.body_vel = info.velocity;
object/src/Bullet.cpp:    this->mov.up = info.dir;
object/src/Bullet.cpp:    this->sprite.setPosition(info.position);
object/src/Bullet.cpp:    this->lifetime = info.lifetime;
object/src/Bullet.cpp:    this->update_frame();
object/src/Bullet.cpp:    if (std::fabsf(this->mov.up.lengthSquared() - 1.0F) >
object/src/Bullet.cpp:      this->mov.up = this->mov.up.normalized();
object/src/Bullet.cpp:    this->mov.right = this->mov.up.perpendicular().normalized();
object/src/Bullet.cpp:      ctx.world_size.contains(this->sprite.getPosition());
object/src/Bullet.cpp:    bool const time_check = this->lifetime > 0;
object/include/Bullet.hpp:      return this->track.accel(ctx);
object/include/Bullet.hpp:    bool isAlive() const { return this->alive; }
object/include/helpers.hpp:      sf::Vector2f velocity() const { return this->up * this->body_vel; }
object/include/helpers.hpp:        this->up = vel.normalized();
object/include/helpers.hpp:        this->body_vel = vel.length();
src/SFMLApp.cpp:    wld_ctx(this->window_.getSize(), this->clock_)
src/SFMLApp.cpp:    this->window_.setFramerateLimit(60);
src/SFMLApp.cpp:    this->window_.setPosition(
src/SFMLApp.cpp:    this->window_.setKeyRepeatEnabled(false);
src/SFMLApp.cpp:    this->settings.antiAliasingLevel = 8;
src/SFMLApp.cpp:    this->log_text_.setFillColor(sf::Color::Yellow);
src/SFMLApp.cpp:      this->update_log("Joystick 0 connected");
src/SFMLApp.cpp:    while (this->window_.isOpen()) {
src/SFMLApp.cpp:      this->dt = this->clock_.getElapsedTime().asSeconds() - last_stamp;
src/SFMLApp.cpp:      last_stamp = this->clock_.getElapsedTime().asSeconds();
src/SFMLApp.cpp:      this->window_.clear();
src/SFMLApp.cpp:      this->window_.handleEvents([this](auto const& event) {
src/SFMLApp.cpp:        this->handle(event);
src/SFMLApp.cpp:      this->fire_check();
src/SFMLApp.cpp:      this->player_.move(wld_ctx, dt);
src/SFMLApp.cpp:      for (auto& obj : this->bullet_pool_) {
src/SFMLApp.cpp:        obj.update(this->wld_ctx, this->str_ctx, dt);
src/SFMLApp.cpp:      this->window_.draw(this->player_.body);
src/SFMLApp.cpp:      this->window_.draw(this->player_.reticle);
src/SFMLApp.cpp:      for (auto const& obj : this->bullet_pool_) {
src/SFMLApp.cpp:        this->window_.draw(obj.sprite);
src/SFMLApp.cpp:      this->bullet_pool_.release();
src/SFMLApp.cpp:      this->update_log(
src/SFMLApp.cpp:        std::format("Bullet Count: {}", this->bullet_pool_.size())
src/SFMLApp.cpp:      this->log();
src/SFMLApp.cpp:      this->window_.display();
src/SFMLApp.cpp:    for (std::size_t i = 0; i < this->logs_.size(); ++i) {
src/SFMLApp.cpp:      this->log_text_.setPosition(
src/SFMLApp.cpp:      this->log_text_.setString(this->logs_[i]);
src/SFMLApp.cpp:      this->window_.draw(this->log_text_);
src/SFMLApp.cpp:    if (this->logs_.size() == 12U) {
src/SFMLApp.cpp:      this->logs_.pop_front();
src/SFMLApp.cpp:    this->logs_.emplace_back(text);
src/SFMLApp.cpp:    if (this->player_.shoot.strength.lengthSquared() > 0) {
src/SFMLApp.cpp:        this->player_.fire(this->wld_ctx, dt),
src/SFMLApp.cpp:        [this](auto const& info) { this->bullet_pool_.get(info); }
src/SFMLApp.cpp:    this->window_.close();
src/SFMLApp.cpp:      this->window_.close();
src/SFMLApp.cpp:    this->update_log(std::format("Pressed Button: {}", event.button));
src/SFMLApp.cpp:      this->deadzone(
src/SFMLApp.cpp:        this->player_.mov.strength, {pos, this->player_.mov.strength.y}
src/SFMLApp.cpp:      this->deadzone(
src/SFMLApp.cpp:        this->player_.mov.strength, {this->player_.mov.strength.x, pos}
src/SFMLApp.cpp:      this->deadzone(
src/SFMLApp.cpp:        this->player_.shoot.strength, {pos, this->player_.shoot.strength.y}
src/SFMLApp.cpp:      this->deadzone(
src/SFMLApp.cpp:        this->player_.shoot.strength, {this->player_.shoot.strength.x, pos}
src/SFMLApp.cpp:    // this->update_log("Unhandled Event\n");
object/include/Object.hpp:    size_t size() const { return this->objects_.size(); }
object/include/Object.hpp:    iterator begin() { return this->objects_.begin(); }
object/include/Object.hpp:    iterator end() { return this->objects_.begin() + this->last_; }
object/include/Object.hpp:    const_iterator begin() const { return this->objects_.begin(); }
object/include/Object.hpp:      return this->objects_.begin() + this->last_;
object/include/Object.hpp:    if (this->last_ == this->objects_.size()) {
object/include/Object.hpp:      this->objects_.emplace_back(internal::build_object<Object>(info));
object/include/Object.hpp:      this->last_++;
object/include/Object.hpp:    auto& obj = this->objects_[this->last_];
object/include/Object.hpp:    this->last_++;
object/include/Object.hpp:    while (idx < this->last_) {
object/include/Object.hpp:      auto& obj = this->objects_[idx++];
object/include/Object.hpp:        std::swap(obj, this->objects_[--this->last_]);
object/include/Player.hpp:    sf::Vector2f const& forward() const { return this->mov.up; }
object/include/Player.hpp:    sf::Vector2f const& right() const { return this->mov.right; }
